<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pzzzzz的阁楼</title>
  
  <subtitle>幸福往往是摸得透彻，&lt;br/&gt;而敬业的心却常常隐藏。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pzzzzz5142.github.io/"/>
  <updated>2021-01-31T11:43:15.386Z</updated>
  <id>https://pzzzzz5142.github.io/</id>
  
  <author>
    <name>Pzzzzz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最近真摸啊！</title>
    <link href="https://pzzzzz5142.github.io/uncategorized/%E6%9C%80%E8%BF%91%E7%9C%9F%E6%91%B8%E5%95%8A%EF%BC%81/"/>
    <id>https://pzzzzz5142.github.io/uncategorized/%E6%9C%80%E8%BF%91%E7%9C%9F%E6%91%B8%E5%95%8A%EF%BC%81/</id>
    <published>2021-01-31T11:35:27.000Z</published>
    <updated>2021-01-31T11:43:15.386Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://pzzzzz5142.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>双十一买了个电动牙刷</title>
    <link href="https://pzzzzz5142.github.io/uncategorized/%E5%8F%8C%E5%8D%81%E4%B8%80%E4%B9%B0%E4%BA%86%E4%B8%AA%E7%94%B5%E5%8A%A8%E7%89%99%E5%88%B7/"/>
    <id>https://pzzzzz5142.github.io/uncategorized/%E5%8F%8C%E5%8D%81%E4%B8%80%E4%B9%B0%E4%BA%86%E4%B8%AA%E7%94%B5%E5%8A%A8%E7%89%99%E5%88%B7/</id>
    <published>2020-11-13T12:28:36.000Z</published>
    <updated>2020-11-13T15:08:50.839Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>本文由双拼打出。</p></blockquote><a id="more"></a><h1 id="起因">起因</h1><p>但凡写文章，总是要有一个起因经过结果。那什么是起因呢？这还得从我每天的摸鱼生活说起。</p><p>摸鱼老三件：知乎、nga、bilibili。然后在我愉快的摸鱼的时候，知乎就一直给我推荐什么🐛牙器。老实说我一直都有搞好牙齿的觉悟的，可惜总觉得压线这jb东西太tm麻烦了。掏牙缝还好，最让我难以接受的是每次都会整得我食指都是乌的，感觉就很狗屎。所以呢，这个🐛牙器看起来就很友好，不会把我可爱的食指弄乌。但是看着看着我就觉得有点不对劲。首先最让我难以接受的点就是它太jb贵了，正常一点的都要300的样子。你说这300块能全包了也行，但是我又看到网上说这个🐛牙器只能搞定40%的污渍，其余的60%主要还是通过刷牙解决的。这300块只能搞定40%，而且还tm多了100%的工作量，而且<strong>还花了300块钱！</strong>这简直是岂有此理？！</p><p>然后我又合计了一下，我觉得我刷牙其实很不认真，如果我买个电动牙刷，不仅能在不认真刷牙的基础上工作量不怎么变动，而且还能让刷牙效果++！相当于是花同样的300块钱，获得在标准流程下的50%的工作量（这是我预估的平时不认真刷牙的程度 （（），和接近100%的刷牙效果！这不比那破🐛牙器好多了？</p><p>于是，这就是我双十一买了一个电动牙刷的起因。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文由双拼打出。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://pzzzzz5142.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Why？</title>
    <link href="https://pzzzzz5142.github.io/uncategorized/Why%EF%BC%9F/"/>
    <id>https://pzzzzz5142.github.io/uncategorized/Why%EF%BC%9F/</id>
    <published>2020-09-19T02:15:06.000Z</published>
    <updated>2021-01-31T11:36:56.259Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="prologue">Prologue</h1><p>很早的时候，大概是高中时期吧（<del>高中时期就算是很早吗？？？</del>），总是有一个人类的终极目的问题困扰着我，<strong>Why？</strong>这个<strong>为什么</strong>是关于许多事情的<strong>为什么</strong>。譬如，你<strong>为什么</strong>吃饭？你<strong>为什么</strong>睡觉？你<strong>为什么</strong>学习？你<strong>为什么</strong>努力？你<strong>为什么</strong>考带学？你，又<strong>为什么</strong>活着？前两个问题还算是非常好解释的。答案很简单，你不这么干早跪了，放现在坟头草都三丈高了吧。但是后几个问题倒是比较难以回答，惶且不论最后一个人生的终极问题，这掐头去尾的三个问题可是结结实实的成为了我高中三年的最大困惑。虽然想这些问题也让我感到非常的震惊（特么别的小朋友都认认真真的在复习准备考试，宁搁这儿干嘛呢？），但是很不幸，年少无知而又中二的我总是很想问一句，为什么？因此，仅以这篇随笔来稍稍记录一下，本科即将完成的我，现在关于这些问题的所思所想。</p><a id="more"></a><h1 id="smjb">SMJB？？</h1><p>大概是从小家里管得比较严吧，也没有人给我解释这些问题。只是用诸如，”你不好好读书，将来要后悔的“、”什么年龄段做什么年龄段的事“等等标准答案来回答我。可惜，如果我就这么被满足了，那我也就对不起年少无知而又中二的名号了。同时，作为一个喜欢刨根问底的人，俗称，钻牛角尖的人，我很清楚我很难做到不问为什么，硬着往上干。像是觉得世间万物都应该如数学公理一样，这些问题的答案也应该有一个不可否认的坚实的公理作为这些解释的原因。毕竟，我很喜欢那种通过几个公理，推出整个数学体系的过程，我也认真的觉得，这些问题都是一个有向无环图，一个个节点代表着结论，而一条条边代表着推理过程。而我想做的，就是找到源头，找到没有入度的节点 ，找到所有行为动机的那些个没有为什么的原始冲动。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;prologue&quot;&gt;Prologue&lt;/h1&gt;
&lt;p&gt;很早的时候，大概是高中时期吧（&lt;del&gt;高中时期就算是很早吗？？？&lt;/del&gt;），总是有一个人类的终极目的问题困扰着我，&lt;strong&gt;Why？&lt;/strong&gt;这个&lt;strong&gt;为什么&lt;/strong&gt;是关于许多事情的&lt;strong&gt;为什么&lt;/strong&gt;。譬如，你&lt;strong&gt;为什么&lt;/strong&gt;吃饭？你&lt;strong&gt;为什么&lt;/strong&gt;睡觉？你&lt;strong&gt;为什么&lt;/strong&gt;学习？你&lt;strong&gt;为什么&lt;/strong&gt;努力？你&lt;strong&gt;为什么&lt;/strong&gt;考带学？你，又&lt;strong&gt;为什么&lt;/strong&gt;活着？前两个问题还算是非常好解释的。答案很简单，你不这么干早跪了，放现在坟头草都三丈高了吧。但是后几个问题倒是比较难以回答，惶且不论最后一个人生的终极问题，这掐头去尾的三个问题可是结结实实的成为了我高中三年的最大困惑。虽然想这些问题也让我感到非常的震惊（特么别的小朋友都认认真真的在复习准备考试，宁搁这儿干嘛呢？），但是很不幸，年少无知而又中二的我总是很想问一句，为什么？因此，仅以这篇随笔来稍稍记录一下，本科即将完成的我，现在关于这些问题的所思所想。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://pzzzzz5142.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱学习笔记（二）</title>
    <link href="https://pzzzzz5142.github.io/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://pzzzzz5142.github.io/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-07-25T16:00:00.000Z</published>
    <updated>2020-07-26T18:11:46.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="chapter-3">Chapter 3</h1><a id="more"></a><h2 id="什么是领域短语挖掘与其他相关任务有什么区别">什么是领域短语挖掘？与其他相关任务有什么区别？</h2><p><strong>最先的前提：</strong>构建知识图谱的第一步便是获取图谱中的实体。</p><p>而相对应的，领域短语挖掘便是用于发现领域相关的短语，识别出领域相关的实体。</p><blockquote><p>领域短语挖掘指的是从给定的领域语料（将大量的文档融合在一起组成的一个语料）中自动的挖掘该领域的高质量短语的过程。</p></blockquote><p>同时，领域短语挖掘主要从以下四个方面来判别该短语的质量如何：</p><ul><li><strong>频率</strong>：一般低频词汇可能是拼写错误或是不常用单词。但是值得注意的是，高频短语可能不是高质量短语，比如中文中的连接词如“首先”、“其次”等等。</li><li><strong>一致性</strong>：一致性指一个N-Gram的搭配频率明显高于各部分组合起来的概率。即不同单词搭配是否合理或者常见。</li><li><strong>信息量</strong>：指短语携带的信息。如“机器学习”在机器学习语料中可能出现频率较高，但是其本身携带的信息并不多。</li><li><strong>完整性</strong>：指一个短语是否完整。如Support Vector Machine中Vector Machine就是不完整、无意义的。</li></ul><p>其与其他相关任务的区别如下：</p><ul><li><strong>LDA</strong>：LDA主要是输入若干篇文档，输出的是每篇文档的主题分布，以及每个词的所属主题。其思想大致上是认为每个文档可能含有不同主题，根据每个词的主题与在文档中的占比来确认该文档的主题构成。而领域<strong>关心的则是各个文档中的实体是什么，而对实体属于哪个主题并不关心。</strong>而先识别出实体再使用LDA，效果会更好。</li><li><strong>关键词抽取</strong>：关键词类似于Key word，是预料中最具代表性的词，而且一般数量也不多，偏总结性质。</li><li><strong>新词发现</strong>：用于发现不在词汇库中不存在的词。</li></ul><h2 id="基于规则的领域挖掘有什么缺陷">基于规则的领域挖掘有什么缺陷？</h2><p>规则一般是手动人工规定的，存在一定局限性。</p><pre><code>1. 领域迁移困难，一般一个领域的规则很难用于其他领域。2. 代价高昂。人工费太贵了。而且难以穷举所有规则。</code></pre><h2 id="基于学习模型的短语挖掘的过程">基于学习模型的短语挖掘的过程</h2><ol type="1"><li><strong>候选短语生成</strong>：一般采用出现频次高于一个阈值的N-Gram作为候选短语。</li><li><strong>统计特征计算</strong>：计算候选短语的特征。如tf-idf、词频矩阵、PMI等。</li><li><strong>质量评分</strong>：通过一定手段对短语质量进行评分。</li><li><strong>排序输出</strong>：根据上一步的评分来输出最终结果。</li></ol><p>同时如果是监督学习，则需要加上<strong>样本标注</strong>和<strong>分类器学习</strong>。这也是理所应当的。</p><h2 id="基于规则的缩略词抽取有什么缺陷如何克服">基于规则的缩略词抽取有什么缺陷？如何克服？</h2><p>面对某些缩略词的出现形式，有可能<strong>很难定义一个规则</strong>。比如上海交通大学可以被称作上交、上海交大、上交大，但是被称作上海交就很奇怪。而且这种规则很难去定义，因为约定俗成的东西很难可以摸出规律。</p><p>面对这种问题，有人遍提出采取马尔可夫逻辑网之类的方法来规避这些问题。</p><h2 id="同义词挖掘有什么常见方法">同义词挖掘有什么常见方法？</h2><ul><li><p><strong>基于同义词资源</strong>：常见的如维基百科、字典等，一般都会列出相应的同义词。而且一般列出的格式较为规范，因此可以很容易的提取出相应的同义词。</p></li><li><p><strong>基于模式匹配</strong>：在文章中，一些常用的句式一般代表同义词。比如X，又被称作Y，就是一个很典型的句式。但是同上述的基于规则的方法相同，这种方法严重依赖于人工，而且可能会分解出许多不应当是同义词的词语对，同时成本高昂。所以下面一种自举法则是尝试改变这种困境。</p></li><li><p><strong>自举法</strong>：通过自举来自动发现模式。基本步骤便是：</p><ul><li>准备数据，同时准备初始模式。</li><li>模式匹配：使用当前已有模式匹配同义词。</li><li>模式发现：使用当前已有的同义词，发现新的模式。</li><li>重复2-3，直到无法发现新同义词</li></ul><p>但是这种方发现的新模式质量堪忧。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;chapter-3&quot;&gt;Chapter 3&lt;/h1&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://pzzzzz5142.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="知识图谱" scheme="https://pzzzzz5142.github.io/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
      <category term="学习" scheme="https://pzzzzz5142.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="知识图谱" scheme="https://pzzzzz5142.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
      <category term="基础" scheme="https://pzzzzz5142.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>朴素贝叶斯分类器</title>
    <link href="https://pzzzzz5142.github.io/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <id>https://pzzzzz5142.github.io/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/</id>
    <published>2020-07-16T16:28:13.000Z</published>
    <updated>2020-07-17T02:41:57.383Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="朴素贝叶斯分类器">朴素贝叶斯分类器</h1><blockquote><p>分类，就是分类。或是分为 1，抑或是分为 0。</p></blockquote><a id="more"></a><h2 id="原理">原理</h2><p>计算机的分类大致上便是给定特征，然后输出结果。</p><p>而贝叶斯分类器本身就是一种基于条件概率公式的分类器。</p><p><span class="math display">\[P(A|C)=\frac{P(C|A)*P(A)}{P(C)}\]</span></p><p>大致转换为人话就是：</p><p><span class="math display">\[P(类别|特征)=\frac{P(特征|类别)*P(类别)}{P(特征)}\]</span></p><p>这个公式有什么好处呢？那就是<span class="math inline">\(P(特征|类别)\)</span>、<span class="math inline">\(P(类别 )\)</span>，和<span class="math inline">\(P(特征)\)</span>都是可以通过数据集统计到的，当数据集够大，那么我们也就能够通过数据集本身统计到的频率来模拟概率。从而当我们给定一个特征的时候，我们能够根据统计到的信息计算在有这个特征的条件下得到的概率是多少。得到了这个条件概率，我们自然能根据这个概率对这个特征进行分类。</p><p>当然，我们也不可能只有一个特征。而这就是朴素贝叶斯拉垮的其中一个点了，他假设特征是不相关的。即认为：</p><p><span class="math display">\[P(特征)=P(特征_1)*P(特征_2)*...*P(特征_n)\]</span></p><p>那么上述公式便改写为：</p><p><span class="math display">\[P(类别|特征)=\frac{P(特征|类别)*P(类别)}{P(特征)}=\frac{P(类别)}{P(特征)}\prod_{i=0}^{n}P(特征_i)\]</span></p><p>这是一个有一定道理的假设。因为的确虽然特征之间难免有关联，但是一般来说关联没有那么的大。而且如果计算机要去真正的处理这些关联的话，那计算量可是相当的恐怖。</p><h2 id="code">Code</h2><p>计算机届一个很著名的话便是：</p><blockquote><p>What i can‘t code is what i don't know</p></blockquote><p>那么我们话不多说直接开始代码部分。这次的代码部分我采用的UCI的adult数据集。数据地址在<a href="http://archive.ics.uci.edu/ml/datasets/Adult" target="_blank" rel="noopener">这里</a>。</p><h3 id="数据集的含义">数据集的含义</h3><p>该数据从美国1994年人口普查数据库中抽取而来，因此也称作“人口普查收入”数据集，共包含48842条记录，年收入大于50k的占比23.93%，年收入小于50k的占比76.07%，数据集已经划分为训练数据32561条和测试数据16281条。该数据集类变量为年收入是否超过50k，属性变量包括年龄、工种、学历、职业等14类重要信息，其中有8类属于类别离散型变量，另外6类属于数值连续型变量。该数据集是一个分类数据集，用来预测年收入是否超过50k。</p><table><thead><tr class="header"><th>数据集特征：</th><th>多变量</th><th>记录数：</th><th>48842</th><th>领域：</th><th>社会</th></tr></thead><tbody><tr class="odd"><td>属性特征：</td><td>类别型、整数型</td><td>属性数目：</td><td>14</td><td>捐赠日期：</td><td>1996-05-01</td></tr><tr class="even"><td>相关应用：</td><td>分类</td><td>缺失值？</td><td>有</td><td>网站点击数：</td><td>1059012</td></tr></tbody></table><p>14个属性变量具体介绍如下：</p><table><thead><tr class="header"><th>属性名</th><th>类型</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>age</td><td>continuous</td><td>年龄</td></tr><tr class="even"><td>workclass</td><td>discrete</td><td>工作类别</td></tr><tr class="odd"><td>fnlwgt</td><td>continuous</td><td>序号</td></tr><tr class="even"><td>education</td><td>discrete</td><td>受教育程度</td></tr><tr class="odd"><td>education-num</td><td>continuous</td><td>受教育时间</td></tr><tr class="even"><td>marital-status</td><td>discrete</td><td>婚姻状况</td></tr><tr class="odd"><td>occupation</td><td>discrete</td><td>职业</td></tr><tr class="even"><td>relationship</td><td>discrete</td><td>社会角色</td></tr><tr class="odd"><td>race</td><td>discrete</td><td>种族</td></tr><tr class="even"><td>sex</td><td>discrete</td><td>性别</td></tr><tr class="odd"><td>capital-gain</td><td>continuous</td><td>资本收益</td></tr><tr class="even"><td>capital-loss</td><td>continuous</td><td>资本支出</td></tr><tr class="odd"><td>hours-per-week</td><td>continuous</td><td>每周工作时间</td></tr><tr class="even"><td>native-country</td><td>discrete</td><td>国籍</td></tr></tbody></table><p>（这一小节全部抄自<a href="https://blog.csdn.net/hohaizx/java/article/details/79084774" target="_blank" rel="noopener">这里</a></p><h3 id="数据的处理">数据的处理！</h3><p>一般而言数据预处理是比较简单的项目，但是这次我我是直接在数据读取的时候就统计特征频率，因此还是有单独列出来讲解的必要。</p><p>大致思路就是用一个三维的矩阵来存储每一个特征的值对应的类别。如果是连续的值便对他进行离散化。</p><p>其中，dataMatrix第一维便是特征的；类别，第二维是类别中不同的值，第三维是一个固定的两个元素的列表，第一个元素代表年薪小于50k的值的个数，第二个元素代表年薪大于50k的个数。</p><h4 id="取了哪些特征">取了哪些特征？</h4><p>当前取了如下特征：</p><ol type="1"><li>所有的原生离散型数据特征</li><li>由于年龄最大为 90 岁，故以 10 岁为单位，共计9类进行离散化。</li><li>由于工作时长最大为 99 小时，故以 5 小时为单位，共计20类进行离散化。</li><li>遇到未知类别，则完全抛弃不处理。</li></ol><h4 id="数据预处理的代码">数据预处理的代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span>  <span class="comment"># 年薪大于50k的人数</span></span><br><span class="line">f = <span class="number">0</span>  <span class="comment"># 年薪小于50k的人数</span></span><br><span class="line"><span class="comment"># 从文件中加载数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> t, f</span><br><span class="line">    dataMatrix = [[[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(v) + <span class="number">1</span>)] <span class="keyword">for</span> _, v <span class="keyword">in</span> value.items()]</span><br><span class="line">    <span class="comment"># 这里给出了python 中读取文件的简便方式</span></span><br><span class="line">    fl = open(path)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fl.readlines():</span><br><span class="line">        <span class="comment"># print(line)</span></span><br><span class="line">        lineList = line.strip().split(<span class="string">","</span>)</span><br><span class="line">        <span class="keyword">if</span> len(lineList) &lt; <span class="number">13</span>:  <span class="comment"># 处理空行和不和条件的行</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lineList = [i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> lineList]</span><br><span class="line">        <span class="keyword">if</span> lineList[<span class="number">-1</span>] == <span class="string">"&lt;=50K"</span>:  <span class="comment"># 统计 t 和 f</span></span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(label)):</span><br><span class="line">            <span class="keyword">try</span>:  <span class="comment"># 因为有离散的值，所以用 try 语句块来分别处理离散的值和连续的值</span></span><br><span class="line">                dataMatrix[i][value[label[i]].index(lineList[i])][</span><br><span class="line">                    <span class="number">1</span> <span class="keyword">if</span> lineList[<span class="number">-1</span>].strip() == <span class="string">"&lt;=50K"</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                ] += <span class="number">1</span>  <span class="comment"># value是一个类别和种类的字典。因为实在太长就没有列出。</span></span><br><span class="line">                dataMatrix[i][<span class="number">-1</span>][<span class="number">1</span> <span class="keyword">if</span> lineList[<span class="number">-1</span>].strip() == <span class="string">"&lt;=50K"</span> <span class="keyword">else</span> <span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">if</span> label[i] == <span class="string">"hours-per-week"</span>:</span><br><span class="line">                    <span class="keyword">if</span> len(dataMatrix[i]) == <span class="number">2</span>:</span><br><span class="line">                        dataMatrix[i] = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">21</span>)]</span><br><span class="line">                    dataMatrix[i][int(float(lineList[i]) / <span class="number">5</span>)][  <span class="comment"># 以5为单位，离散化连续数值</span></span><br><span class="line">                        <span class="number">1</span> <span class="keyword">if</span> lineList[<span class="number">-1</span>].strip() == <span class="string">"&lt;=50K"</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    ] += <span class="number">1</span></span><br><span class="line">                    dataMatrix[i][<span class="number">-1</span>][<span class="number">1</span> <span class="keyword">if</span> lineList[<span class="number">-1</span>].strip() == <span class="string">"&lt;=50K"</span> <span class="keyword">else</span> <span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> label[i] == <span class="string">"age"</span>:</span><br><span class="line">                    <span class="keyword">if</span> len(dataMatrix[i]) == <span class="number">2</span>:</span><br><span class="line">                        dataMatrix[i] = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">11</span>)]</span><br><span class="line">                    dataMatrix[i][int(float(lineList[i]) / <span class="number">10</span>)][  <span class="comment"># 以10为单位，离散化连续数值</span></span><br><span class="line">                        <span class="number">1</span> <span class="keyword">if</span> lineList[<span class="number">-1</span>].strip() == <span class="string">"&lt;=50K"</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    ] += <span class="number">1</span></span><br><span class="line">                    dataMatrix[i][<span class="number">-1</span>][<span class="number">1</span> <span class="keyword">if</span> lineList[<span class="number">-1</span>].strip() == <span class="string">"&lt;=50K"</span> <span class="keyword">else</span> <span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">    fl.close()</span><br><span class="line">    <span class="keyword">return</span> dataMatrix</span><br></pre></td></tr></table></figure><h4 id="平滑处理">平滑处理</h4><p>平滑处理就是非常暴力的通过对概率为0对值加一，然后总数加一</p><h4 id="平滑处理的代码">平滑处理的代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smooth</span><span class="params">(Matrix)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> t, f</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Matrix:</span><br><span class="line">        <span class="keyword">for</span> ind, val <span class="keyword">in</span> enumerate(i):</span><br><span class="line">            <span class="keyword">if</span> val[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                i[ind][<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                i[<span class="number">-1</span>][<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                f += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> val[<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                i[ind][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                i[<span class="number">-1</span>][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                t += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="结果">结果</h2><p>搞完了代码，总得上个结果。</p><p>一开始叫我弄离散化连续值我是拒绝的，因为我实在懒得搞。</p><p>然后得到了这个结果：</p><figure><img data-src="image-20200717010456670.png" alt="image-20200717010456670" /><figcaption aria-hidden="true">image-20200717010456670</figcaption></figure><p>实际上，由于这个数据集本身很大，所以出现0概率的情况属实太少了，因此带不带平滑处理貌似区别也不少很大。</p><p>但是我对这个结果不是很满意。于是我便加上了两个我认为重要的数据的离散化处理，并得到了如下结果：</p><figure><img data-src="image-20200717010658444.png" alt="image-20200717010658444" /><figcaption aria-hidden="true">image-20200717010658444</figcaption></figure><p>这次准确率提升了3%，而f1值提升了将近10%！这可太好了！而同时，平滑处理本身也对结果有一定的优化，只是这个优化确实是有限的。</p><h2 id="小小的问题">小小的问题</h2><p>在讲原理的时候我便提到过，当特征之间不是无关的时候，那个假设可能是错误的。而这也的确在本次运行中出现了。当我们在测试函数中加入如下两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> Ok &gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> Not &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure><p>其中<code>Ok</code>是在该特征下，这个人年薪5w🔪以上的概率，<code>Not</code>变量含义则与之相反。那么我们继续运行一下。</p><figure><img data-src="image-20200717011622886.png" alt="image-20200717011622886" /><figcaption aria-hidden="true">image-20200717011622886</figcaption></figure><p>啊哈，他报错了。这说明确实在这些变量之间，确实是有相关性的。但这也是朴素贝叶斯分类器无能为力的地方。举个例子，有如下关系：</p><table><thead><tr class="header"><th>熬夜吗？</th><th>情况</th></tr></thead><tbody><tr class="odd"><td>熬夜</td><td>买新游戏了</td></tr><tr class="even"><td>不熬夜</td><td>没买新游戏</td></tr></tbody></table><p>显然，只有一个变量的情况下，我们计算得到<span class="math inline">\(P(买新游戏|熬夜)=\frac{P(熬夜|买新游戏)*P(买新游戏)}{P(熬夜)}=\frac{1*\frac{1}{2}}{\frac{1}{2}}\)</span>。</p><p>但是如果我们加一维数据：</p><table><thead><tr class="header"><th>熬夜吗？</th><th>出去玩</th><th>情况</th></tr></thead><tbody><tr class="odd"><td>熬夜</td><td>出去</td><td>买新游戏</td></tr><tr class="even"><td>熬夜</td><td>出去</td><td>买新游戏</td></tr><tr class="odd"><td>不熬夜</td><td>不出去玩</td><td>没买新游戏</td></tr><tr class="even"><td>熬夜</td><td>不出去玩</td><td>买新游戏</td></tr></tbody></table><p>那么我们计算出<span class="math inline">\(P(买新游戏|熬夜，出去玩)=\frac{P(熬夜，出去玩|买新游戏)*P(买新游戏)}{P(熬夜，出去玩)}=\frac{1*\frac{2}{3}}{\frac{3}{4}*\frac{1}{2}}=\frac{16}{9}\)</span>。</p><p>等等，这概率为什么会大于1？为什么我们加了一个毫不相干的数据他就炸了呢？但是仔细看这个数据就不难发现，熬夜的情况下有<span class="math inline">\(\frac23\)</span>的情况是要出去玩的。也就是说虽然在实际生活中看起来这两维毫不相干，但是数学上我们看起来的确是相关的。这也是贝叶斯分类器的一个小局限所在。</p><h2 id="总结">总结</h2><p>贝叶斯的优点很多：</p><ol type="1"><li>它足够简单，遇事不决先试试成本很低，而且效果也颇为不错。</li><li>运行速度快</li><li>数学原理明确，可解释性强，结果稳定</li></ol><p>但是他的缺点也很明显：</p><ol type="1"><li><strong>各特征之间无关，这个假设太强了点</strong></li><li>模型有点简单，面对复杂的问题有些力不从心</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;朴素贝叶斯分类器&quot;&gt;朴素贝叶斯分类器&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;分类，就是分类。或是分为 1，抑或是分为 0。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://pzzzzz5142.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="知识图谱" scheme="https://pzzzzz5142.github.io/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
      <category term="学习" scheme="https://pzzzzz5142.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="基础" scheme="https://pzzzzz5142.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="机器学习" scheme="https://pzzzzz5142.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱学习笔记（一）</title>
    <link href="https://pzzzzz5142.github.io/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://pzzzzz5142.github.io/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-07-09T16:38:56.000Z</published>
    <updated>2020-07-09T16:46:48.340Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>学习笔记，便是，记录学习的历程。第一章的知识偏向于概念性的内容，由此我决定采用回答书后习题的方式来记录第一章的学习</p></blockquote><a id="more"></a><h1 id="chapter-1-知识图谱-概念与技术">Chapter 1 《知识图谱 · 概念与技术》</h1><h2 id="什么是知识图谱知识图谱和传统语义网络有什么区别">什么是知识图谱？知识图谱和传统语义网络有什么区别？</h2><h4 id="知识图谱的概念"><strong>知识图谱的概念</strong>：</h4><ol type="1"><li><p>狭义的概念</p><p>知识图谱作为一种知识表示形式，是一种大规模的语义网络，包含实体（Entity）、概念（Concept）及其之间的各种语义关系。</p><p><strong>重点！</strong>1、是<strong>语义网络</strong> 2、是<strong>大规模的</strong></p><p>Furthermore：什么是实体、概念、值？</p><ul><li><p>实体：实体必须是是能独立存在的、不依附于其他东西而存在的。例如：脱离人谈身高是没有意义的</p></li><li><p>概念（抑或是更加通俗易懂的 “类”）：就理解成一个虚基类即可。概念化（Conceptualize），就是将实体抽象为类。范畴化（Categorize），就是将类实例化</p></li><li><p>值：就是实体的属性的值。</p></li><li><p>知识图谱的边：有两种，分别为<strong>属性</strong>和<strong>关系</strong>，两类。</p><p><strong>！！重点</strong>：属性与关系的区别</p><p><em>主要是在长推理过程的区别。如果在推理过程中遇到属性，则推理宣告结束。</em></p><p>然而，遇到属性可能也不一定代表推理的结束。如果用书上的例子来讲，<strong>苏格拉底的导师的出生时间</strong>这个例子，如果我们拓展出去，推展为<strong>苏格拉底的导师的出生时间的月份</strong>，可以看出我们可以从出生时间推到 出生时间是具有月份这一属性的。</p><p>同时，属性本身也可能具有运算操作，比如我们说<strong>苏格拉底的导师的出生时间的前一天</strong>。</p><p>然而，这种属性的属性，以及属性的运算，可能这本书认为是不能算作推理的一部分的。</p></li></ul></li><li><p>广义的概念</p><p>广义上，知识图谱是作为一种技术体系，指代大数据时代知识工程的一系列代表性技术的总和。</p><p>而知识图谱数据人工智能的范畴。</p><p>知识工程其核心内容便是旨在让机器能够利用专家知识以及推理能力解决实际问题。而知识图谱便是一种知识的表现形式。</p></li></ol><h4 id="知识图谱与传统语义网络的区别"><strong>知识图谱与传统语义网络的区别</strong></h4><p>主要是<strong>规模巨大</strong>、<strong>语义丰富</strong>、<strong>质量精良</strong>、<strong>结构友好</strong>。</p><ol type="1"><li><p>规模巨大</p><p>知识图谱中点和边的数量较传统语义网络可大太多了。</p></li><li><p>语义丰富</p><p>第一、由于他规模巨大，所以语义丰富</p><p>第二、由于他建模方法多样，可以更精准的表达语义。比如说我们可以给各个属性赋权，从而能够更加精准的反应语义关系。比如当我们想知道谁是周鸿祎，如果你熟知360，我们可以在你询问的时候为360 CEO这个属性赋以更高的权值，如果你常逛影音论坛，我们也可以在你询问的时候给影音发烧友这个属性赋以更高的权值。这能够快速让你明白周鸿祎是谁。</p></li><li><p>质量精良</p><p>书上认为知识图谱精良是基于其大数据特性。由大数据我们可以从多个来源交叉验证其正确性。</p></li><li><p>结构友好</p><p>可以用计算机语言表示。没了。</p></li></ol><p>Wait a second，<strong>缺点</strong>呢？</p><ol type="1"><li><p>高质量模式缺失</p><p>以数据库为例，数据库是要求严格定义模式（Schema）的，而且也有种种完整性约束。但是知识图谱并不是这样的。因为在现实生活中任何严格定义的数据都有可能有特例。为了特例去扩充定义是吃力有不讨好的事情。</p></li><li><p>封闭世界假设不再成立</p><p>封闭世界假设（Closed World Assumption）是指假定数据库中不存在的知识为假。但是知识图谱的知识可能是不完整的。</p></li><li><p>大规模自动化获取知识成为前提</p><p>知识图谱的一个特征就是大规模。这种大规模的知识图谱如果依赖专家来维护，是极其不现实的。而且与传统知识工程没有本质的区别。</p></li></ol><h2 id="传统知识工程有什么局限性">传统知识工程有什么局限性？</h2><ol type="1"><li><p>隐形知识于过程知识难以表达</p></li><li><p>知识表达的主观性于不一致性</p><p>etc 一个足够矮的有柄的杯子是碗还是杯子？</p></li><li><p>知识难以完备</p><p>etc 互联网搜素引擎方面，用户搜索的内容可能是无穷无尽的。</p></li><li><p>知识更新困难</p><p>比如全球天气数据，这很难做到纯人力及时更新。其实天气预报的出现也是出现计算机之后才有的。</p></li></ol><h2 id="互联网应用有什么特点它对知识工程提出了什么要求">互联网应用有什么特点？它对知识工程提出了什么要求？</h2><h3 id="互联网应用的特点">互联网应用的特点</h3><ol type="1"><li><p>规模巨大</p></li><li><p>精度要求相对不高</p><p>比如搜索引擎从来不要求搜索结果是完全正确的。</p></li><li><p>知识推理简单</p><p>诸如“姚明老婆的儿子的身高”这种搜索是占比较少的。</p></li></ol><h3 id="互联网应用对知识工程的要求">互联网应用对知识工程的要求</h3><p>针对互联网应用，知识工程首先要保证的就是规模大到足够满足互联网的需求。</p><p>而对于其<strong>知识精度</strong>和<strong>推理</strong>方面要求<strong>并不高</strong>。</p><h2 id="知识图谱有什么应用吗举个例子看看">知识图谱有什么应用吗？举个例子看看？</h2><p>这里我讲根据书上的应用类别，给两个类别举一下例子。</p><h3 id="数据分析">数据分析</h3><p>现在许多行业和企业，得益于互联网时代，积累了许多大数据。但是数据本身难以创造价值。这是由于没有很好的管理数据并从中提取语义导致的。这可能会导致分析不够<strong>精准</strong>的问题。同时，对于互联网数据，如果机器具有相应的背景知识，能够分辨出相应的观点，那么对机器进行<strong>精细</strong>分析也有莫大的帮助。</p><p>关于<strong>精准分析</strong>，比如微博热搜榜上的“宝强离婚”、“王宝强离婚”等对完全一致的事件的重复描述。这是由于平台难以将宝强和王宝强合并为一个事件。这可能会导致同一个事件被看作两个事件，从而可能该事件本身的热度权重值被分散到两个事件上，从而对该事件真正的热度值分析出现低估的情况。</p><p>关于<strong>精细分析</strong>。比如汽车厂商专注于用户对于汽车本身的评价等，这些需要计算机拥有相应的关于汽车评价的背景知识。这样机器就能够从互联网数据中剥离出用户关于该汽车厂商的各方面的，多维度的评价。</p><h3 id="智慧搜索">智慧搜索</h3><p>智慧搜素包含以下几个方面：</p><ol type="1"><li><p>精准理解搜索意图</p><p>我们搜索mac更新，特别是在6.23号的搜索。大概率的我们指的是苹果mac系统的更新。因为苹果刚刚发布最新的mac系统，自然对于苹果公司的mac系统应当赋以更高的权值，而不是另一个叫做口红的mac。实际上这也是知识图谱在<strong>搜索引擎</strong>方面的应用。</p></li><li><p>搜索对象复杂化</p><p>当前搜索引擎最广泛的应用便是关于文本的搜索。而在日常网络生活中，的确极大一部分信息是通过文本表达的。比如论坛交流，大部分的教程。而事实上关于视频的搜索也是通过搜索视频标题实现的。这很大一部分程度上是因为最好输入的也是文字。而知识图谱本身便能够让文字的表达更加精准，能够实现给出关键字搜索图片、视频素材等内容。这也是知识图谱在<strong>搜索引擎</strong>方面的应用。</p></li><li><p>搜素粒度多元化</p><p>有时我们搜索可能是一个大文章的小知识点，或者查找一句话的来源，他出自哪本书，也可能是通过搜索一个小说大致剧情来寻找该小说本身。这就是搜索粒度的区别。而当前谷歌搜索已经能够做到搜索到在谷歌图书中收录图书的某一段话的粒度。</p></li><li><p>跨媒体协调搜索</p><p>这里的跨媒体可能是指跨社交媒体平台，也可能是跨信息的传播载体，例如文本、图片等。</p></li></ol><p>而智慧搜索也不一定专注于搜索引擎的优化，同时在设备端的本地搜索也有应用的空间。比如搜索通过搜索本地文档中的某一句话来找到该文档，比如给出照片的时间信息、位置信息，搜索出相应的照片等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习笔记，便是，记录学习的历程。第一章的知识偏向于概念性的内容，由此我决定采用回答书后习题的方式来记录第一章的学习&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://pzzzzz5142.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="知识图谱" scheme="https://pzzzzz5142.github.io/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
      <category term="学习" scheme="https://pzzzzz5142.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="知识图谱" scheme="https://pzzzzz5142.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
      <category term="基础" scheme="https://pzzzzz5142.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HiCity v0.4 记录</title>
    <link href="https://pzzzzz5142.github.io/xjb%E5%86%99/HiCity-v0-4-%E8%AE%B0%E5%BD%95/"/>
    <id>https://pzzzzz5142.github.io/xjb%E5%86%99/HiCity-v0-4-%E8%AE%B0%E5%BD%95/</id>
    <published>2020-04-07T10:33:21.000Z</published>
    <updated>2020-04-12T07:45:27.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>HiCity v0.4 是一个基于pyqt的城市码查询小工具，是我python课的第四次作业。这篇文章则是记录一下在编写这个程序时所遇到的问题和解决方法，以免再次落入同样的窘境之中。</p></blockquote><a id="more"></a><h1 id="prologue">Prologue</h1><p>这个小窗口部件实现了从文件中读取城市代码、从数据库中读入城市代码，以及从文件中把城市代码写入到数据库中。当然，作业中要求要加入数据库的增删查改并没有实现。然而在了解了pyqt的大致使用方法之后，这种功能加起来也不是太难，于是便现在就将 HiCity v0.4 的开发流程记录下来了。</p><p>本篇文章将按照QWiget、QButton与信号与槽、QHBoxLayout/QVBoxLayout与窗口自适应、QTheard、pyqtSignal的顺序来记录如何写一个<strong>有进度条的</strong>、<strong>能自动补全的</strong>基于qt的小应用。</p><h1 id="hicity-v0.4">HiCity v0.4</h1><figure><img data-src="截屏2020-04-07-下午6.57.23.png" title="程序主界面" alt="截屏2020-04-07 下午6.57.23" /><figcaption aria-hidden="true">截屏2020-04-07 下午6.57.23</figcaption></figure><p>这个主界面非常的直白。但是不足的地方在于从文件进行的操作是在源码中写死了的。QT 支持点击一下按钮就调用一个取文件的操作。这个功能的实现会在后续更新。</p><p>写死的文件路径的写法也是有所讲究的。以前我喜欢直接把相对路径的字符串拍上去，但是由于我使用了一个大的文件夹专门写python，这种作业就会单独开一个小文件夹来方便管理。但是在如下文件结构中，往往需要加"homework/"前缀才能正常的访问搭配 <code>data.txt</code> 文件。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- python</span><br><span class="line">    |-- others.py</span><br><span class="line">    |-- homework</span><br><span class="line">        |-- HiCity v0.1.py</span><br><span class="line">        |-- HiCity v0.2.py</span><br><span class="line">        |-- HiCity v0.3.py</span><br><span class="line">        |-- HiCity v0.4.py</span><br><span class="line">        |-- data.txt</span><br></pre></td></tr></table></figure></p><p>但是交作业的时候我们并不知道交上去的作业文件结构是什么样的，也不知道老师的python是在哪个路径下跑的。因此，我们可以通过 <code>os.path.join(os.path.dirname(__file__), "data.txt")</code>来愉快的访问数据文件。因为你交上去的作业py文件和数据总是在一个文件夹下，所以这样就能避免许多路径上的问题。其中<code>os.path.dirname(__file__)</code>是返回当前文件的绝对路径，<code>os.path.join()</code>函数则是将文件路径连接起来。</p><p>下面就是一堆界面的截图。<img data-src="截屏2020-04-07-下午7.26.06.png" title="正在载入的样子" alt="截屏2020-04-07 下午7.26.06" /><img data-src="截屏2020-04-07-下午7.26.13.png" title="载入完成的样子" alt="截屏2020-04-07 下午7.26.13" /><img data-src="截屏2020-04-07-下午7.30.51.png" title="查询的样子" alt="截屏2020-04-07 下午7.30.51" /></p><p>然后，就要开始记录这是怎么实现的了！</p><h2 id="qwiget">QWiget</h2><p>QWiget就是一个窗口类。一个如下的代码能够直接输出一个窗口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QWidget,QApplication</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    app=QApplication(sys.argv)</span><br><span class="line">    win=QWidget()</span><br><span class="line">    win.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><figure><img data-src="截屏2020-04-07-下午7.41.11.png" title="大概长这样" alt="截屏2020-04-07 下午7.41.11" /><figcaption aria-hidden="true">截屏2020-04-07 下午7.41.11</figcaption></figure><p>当然我们的窗口自然不能什么都没有，所以我们常用的方法是继承<code>QWidget</code>类来添加我们想要的元素。那么借用一下<a href="https://pythonspot.com/pyqt5-window/" target="_blank" rel="noopener">官方的教程代码</a>我们就能给这个窗口添加我们想要的元素了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.title = <span class="string">"PyQt5 simple window - pythonspot.com"</span></span><br><span class="line">        self.left = <span class="number">10</span>  <span class="comment"># 这个类可以放很多元素进去。虽然这里放的都是设置窗口相关的元素，但是能放置的不一定非得是Qt相关的元素</span></span><br><span class="line">        self.top = <span class="number">10</span></span><br><span class="line">        self.width = <span class="number">640</span></span><br><span class="line">        self.height = <span class="number">480</span></span><br><span class="line">        self.initUI()  <span class="comment"># 把元素放到窗口上</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.setWindowTitle(self.title)  <span class="comment"># 设置标题</span></span><br><span class="line">        self.setGeometry(self.left, self.top, self.width, self.height)  <span class="comment"># 设置大小</span></span><br><span class="line">        self.show()  <span class="comment"># 放好之后展示窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = App()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><figure><img data-src="截屏2020-04-07-下午7.48.27.png" title="于是他有了预设大小以及一个标题" alt="截屏2020-04-07 下午7.48.27" /><figcaption aria-hidden="true">截屏2020-04-07 下午7.48.27</figcaption></figure><p>如果你要做一个按下按钮才弹出的窗口的话，注意不要在<code>setupUI()</code>函数中使用<code>self.show()</code>函数，否则这个窗口将在创建的时候就展示出来了。</p><h2 id="qbutton与信号与槽">QButton与信号与槽</h2><p>这一部分我将记录一下pyqt中，信号与槽。信号就如同字面意思的信号，例如按下按钮。而有信号发出就得有东西来接收信号。那么接受和处理信号的就由槽函数来完成。我们还是借用<a href="https://pythonspot.com/pyqt5-buttons/" target="_blank" rel="noopener">官方代码</a>来做示范。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget, QPushButton</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> pyqtSlot</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span><span class="params">(QWidget)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.title = <span class="string">'PyQt5 button - pythonspot.com'</span></span><br><span class="line">        self.left = <span class="number">10</span></span><br><span class="line">        self.top = <span class="number">10</span></span><br><span class="line">        self.width = <span class="number">320</span></span><br><span class="line">        self.height = <span class="number">200</span></span><br><span class="line">        self.initUI()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.setWindowTitle(self.title)</span><br><span class="line">        self.setGeometry(self.left, self.top, self.width, self.height)</span><br><span class="line">        </span><br><span class="line">        button = QPushButton(<span class="string">'PyQt5 button'</span>, self) <span class="comment">#按钮创建</span></span><br><span class="line">        button.setToolTip(<span class="string">'This is an example button'</span>) <span class="comment">#创建悬浮提示</span></span><br><span class="line">        button.move(<span class="number">100</span>,<span class="number">70</span>) <span class="comment">#设置位置，不推荐这样用。后面会用到QHBoxLayout来做自适应</span></span><br><span class="line">        button.clicked.connect(self.on_click) <span class="comment">#重点！信号与槽函数相连了！</span></span><br><span class="line">        </span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @pyqtSlot()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_click</span><span class="params">(self)</span>:</span><span class="comment">#自定义的槽函数</span></span><br><span class="line">        print(<span class="string">'PyQt5 button click'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = App()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>这里我们主要关心的是这几行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.clicked.connect(self.on_click)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pyqtSlot()#槽函数的装饰器，可以不用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_click</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'PyQt5 button click'</span>)</span><br></pre></td></tr></table></figure><p>第一行代码表示将点击完成的信号与<code>self.on_click()</code>函数相连接。这表示当按钮被点击之后，按钮发出的点击信号将被<code>self.on_click()</code>函数处理。而<code>@pyqtSlot()</code>装饰器则是将python函数转换为一个槽函数。然而QT允许任意函数作为槽函数被调用，所以可以不用这个装饰器，更多内容可以看<a href="https://stackoverflow.com/questions/45841843/function-of-pyqtslot" target="_blank" rel="noopener">这里</a>。</p><p>同时，如果你的命名格式是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PyQt5.QtCore.pyqtSlot(参数)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_</span>发送者对象名称<span class="title">_</span>发射信号名称<span class="params">(self, 参数)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>那么你可以使用这个函数来完成自动连接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMetaObject.connectSlotsByName(QObject)</span><br></pre></td></tr></table></figure><p>例如下面的写法是和上面的连接方法是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">self.okButton = QPushButton(<span class="string">"OK"</span>, self)</span><br><span class="line"><span class="comment">#使用setObjectName设置对象名称</span></span><br><span class="line">self.okButton.setObjectName(<span class="string">"okButton"</span>)</span><br><span class="line"></span><br><span class="line">QtCore.QMetaObject.connectSlotsByName(self)</span><br><span class="line"></span><br><span class="line"><span class="meta">@QtCore.pyqtSlot()    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_okButton_clicked</span><span class="params">(self)</span>:</span></span><br><span class="line">        print( <span class="string">"单击了OK按钮"</span>)</span><br></pre></td></tr></table></figure><p>代码来自于<a href="https://blog.csdn.net/broadview2006/article/details/80132757?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">这里</a>。</p><h2 id="qhboxlayoutqvboxlayout与窗口自适应">QHBoxLayout/QVBoxLayout与窗口自适应</h2><p>这两个组件主要用来做窗口自适应的。相较于Designer模式，这种代码控制自适应的方式虽然说不够直观，但是却能够精确的把元素放到你想放置的地方。当然除了这两个能够做自适应之外，还有其他的表单式布局和栅格式布局。关于这两种布局可以看<a href="https://zhuanlan.zhihu.com/p/28559136" target="_blank" rel="noopener">这里</a>。</p><p>我们把HiCity布局部分的代码搬过来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initUI</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    QToolTip.setFont(QFont(<span class="string">"SansSerif"</span>, <span class="number">10</span>))</span><br><span class="line">    self.t = test()</span><br><span class="line">    self.t.fin.connect(self.init_cobo)</span><br><span class="line"></span><br><span class="line">    self.setToolTip(<span class="string">"This is a &lt;b&gt;QWidget&lt;/b&gt; widget"</span>)</span><br><span class="line"></span><br><span class="line">    self.btn = QPushButton(<span class="string">"从文件中读取"</span>, self)</span><br><span class="line">    self.btn.clicked.connect(self.t.reactFL)</span><br><span class="line">    self.btn1 = QPushButton(<span class="string">"从数据库中读取"</span>, self)</span><br><span class="line">    self.btn1.clicked.connect(self.t.reactDB)</span><br><span class="line">    self.btn2 = QPushButton(<span class="string">"从文件中写入到数据库"</span>, self)</span><br><span class="line">    self.btn2.clicked.connect(self.t.reactCP)</span><br><span class="line">    self.tit = QLabel(<span class="string">"欢迎使用 HiCity v0.4"</span>, self)</span><br><span class="line"></span><br><span class="line">    self.line = QLabel(<span class="string">'请输入要查询的城市。'</span>,self)</span><br><span class="line">    self.cobo = QComboBox(self)</span><br><span class="line">    self.cobo.setEditable(<span class="literal">True</span>)</span><br><span class="line">    self.cobo.activated.connect(self.qcity)</span><br><span class="line"></span><br><span class="line">    hbox_v=QHBoxLayout()</span><br><span class="line">    hbox_v.addStretch(<span class="number">1</span>)</span><br><span class="line">    hbox_v.addWidget(self.cobo)</span><br><span class="line">    hbox_v.addStretch(<span class="number">1</span>)</span><br><span class="line">    hbox_v.addWidget(self.line)</span><br><span class="line">    hbox_v.addStretch(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    hbox_btn = QHBoxLayout()</span><br><span class="line">    hbox_btn.addStretch(<span class="number">1</span>)</span><br><span class="line">    hbox_btn.addWidget(self.btn)</span><br><span class="line">    hbox_btn.addWidget(self.btn1)</span><br><span class="line">    hbox_btn.addStretch(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    hbox = QHBoxLayout()</span><br><span class="line">    hbox.addStretch(<span class="number">1</span>)</span><br><span class="line">    hbox.addWidget(self.tit)</span><br><span class="line">    hbox.addStretch(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    vbox_tit = QVBoxLayout()</span><br><span class="line">    vbox_tit.addLayout(hbox)</span><br><span class="line">    vbox_tit.addLayout(hbox_btn)</span><br><span class="line">    vbox_tit.addWidget(self.btn2)</span><br><span class="line">    vbox_tit.addStretch(<span class="number">1</span>)</span><br><span class="line">    vbox_tit.addLayout(hbox_v)</span><br><span class="line">    vbox_tit.addStretch(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    hbox_tit = QHBoxLayout()</span><br><span class="line">    hbox_tit.addStretch(<span class="number">1</span>)</span><br><span class="line">    hbox_tit.addLayout(vbox_tit)</span><br><span class="line">    hbox_tit.addStretch(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    self.setLayout(hbox_tit)</span><br></pre></td></tr></table></figure><p>可以看到代码非常的长（大雾）。我们其实只用看一段就明白了QHBoxLayout和QVBoxLayout怎么用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hbox_v=QHBoxLayout()</span><br><span class="line">hbox_v.addStretch(<span class="number">1</span>)</span><br><span class="line">hbox_v.addWidget(self.cobo)</span><br><span class="line">hbox_v.addStretch(<span class="number">1</span>)</span><br><span class="line">hbox_v.addWidget(self.line)</span><br><span class="line">hbox_v.addStretch(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这一段代码中，<code>hbox</code>表示我们创建了一个水平的box。他的<code>addStretch</code>方法则表示增加一个拉伸因子。<code>addWidget</code>表示我们增加一个组件进去。这个拉伸因子是干嘛的呢？他是用来控制组件之间的间隙比例的。按照顺序加入则表示从左到右的元素是什么，而这些元素之间的间距比例又是多少。<img data-src="截屏2020-04-12-下午3.29.51.png" title="把我们的主页面拉大一点" alt="截屏2020-04-07 下午6.57.23" /></p><p>这里对比下面的代码则可以看出，cobo条上下的距离是1:2的关系。这与我们代码中的设计是一致的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vbox_tit = QVBoxLayout()</span><br><span class="line">vbox_tit.addLayout(hbox)</span><br><span class="line">vbox_tit.addLayout(hbox_btn)</span><br><span class="line">vbox_tit.addWidget(self.btn2)</span><br><span class="line">vbox_tit.addStretch(<span class="number">1</span>)</span><br><span class="line">vbox_tit.addLayout(hbox_v)</span><br><span class="line">vbox_tit.addStretch(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>同时，作为一种布局，布局本身也能被插入到另外一个布局中。这样就能支撑我们作出更加符合我们心目中的自适应布局了。</p><p>比如说如果我们直接把所有元素扔进一个QVBoxLayout里面，那么就无法做到两个按钮并排摆放并与其他元素一起位于窗口居中的效果了。那么在这个项目中，我的做法是把两个button放到一个HBox中，然后将这个Box与其他元素一起放入VBox中，这样就能通过做外层的VBox控制元素的垂直排布方式，再在外面嵌套一个HBox来做居中。</p><p>这是用来做按钮并列的水平HBox，居中样式！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbox_btn = QHBoxLayout()</span><br><span class="line">   hbox_btn.addStretch(<span class="number">1</span>)</span><br><span class="line">   hbox_btn.addWidget(self.btn)</span><br><span class="line">   hbox_btn.addWidget(self.btn1)</span><br><span class="line">   hbox_btn.addStretch(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>用来做整体垂直分布控制的VBox</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vbox_tit = QVBoxLayout()</span><br><span class="line">vbox_tit.addLayout(hbox)</span><br><span class="line">vbox_tit.addLayout(hbox_btn)</span><br><span class="line">vbox_tit.addWidget(self.btn2)</span><br><span class="line">vbox_tit.addStretch(<span class="number">1</span>)</span><br><span class="line">vbox_tit.addLayout(hbox_v)</span><br><span class="line">vbox_tit.addStretch(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>用来做整体居中的HBox。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbox_tit = QHBoxLayout()</span><br><span class="line">hbox_tit.addStretch(<span class="number">1</span>)</span><br><span class="line">hbox_tit.addLayout(vbox_tit)</span><br><span class="line">hbox_tit.addStretch(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这大概就是两个Box的简单应用了。</p><h2 id="qtheard">QTheard</h2><p>这是PyQt中的多线程。由于我对多线程还不是很了解，所以这个部分就大致介绍一下我是怎么用这玩意的。我们使用一下<code>thread1=QThread()</code>就成功创建了一个线程。但是这个时候他还没有启动。调用<code>thread1.start()</code>，他就会自动调用自身的<code>run</code>方法。而我这里的做法就是继承这个类，并重载他的<code>run</code>方法，就能实现自己多线程读数据并显示进度条的功能了。这里有些人可能就会问，为什么进度条一定要用多线程呢？因为如果单纯的跑单线程的话，这个界面就会在读文件的时候卡死，所以必须要用多线程以及发信号的方式完成进度条的实现。当然我也尝试过使用async的方法，但是怎么搞都没有成功，索性放弃了。</p><p>我们把QTheard的读文件的方法弄过来看看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(self.path, <span class="string">"r"</span>) <span class="keyword">as</span> fl:</span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line">    lines = fl.readlines()</span><br><span class="line">    lines = [i <span class="keyword">for</span> i <span class="keyword">in</span> lines <span class="keyword">if</span> i != <span class="string">"\n"</span>]</span><br><span class="line">    self.trigger1.emit(len(lines))</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        line = line.strip(<span class="string">"\n"</span>).split(<span class="string">","</span>)</span><br><span class="line">        self.ans[line[<span class="number">0</span>]] = line[<span class="number">1</span>]</span><br><span class="line">        self.trigger.emit(cnt)</span><br><span class="line">        self.trigger2.emit(<span class="string">f"正在读取：<span class="subst">&#123;line[<span class="number">0</span>]&#125;</span>"</span>)</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    self.trigger2.emit(<span class="string">"读取完成！"</span>)</span><br></pre></td></tr></table></figure><h1 id="我去打mhw了剩下的等等再更">我去打MHW了！剩下的等等再更！</h1>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;HiCity v0.4 是一个基于pyqt的城市码查询小工具，是我python课的第四次作业。这篇文章则是记录一下在编写这个程序时所遇到的问题和解决方法，以免再次落入同样的窘境之中。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="xjb写" scheme="https://pzzzzz5142.github.io/categories/xjb%E5%86%99/"/>
    
    
      <category term="备忘" scheme="https://pzzzzz5142.github.io/tags/%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title>动森Q群机器人的 To-DO list！</title>
    <link href="https://pzzzzz5142.github.io/xjb%E5%86%99/%E5%8A%A8%E6%A3%AEQ%E7%BE%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84-To-DO-list%EF%BC%81/"/>
    <id>https://pzzzzz5142.github.io/xjb%E5%86%99/%E5%8A%A8%E6%A3%AEQ%E7%BE%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84-To-DO-list%EF%BC%81/</id>
    <published>2020-04-05T07:11:49.000Z</published>
    <updated>2020-04-08T06:06:13.920Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>正如其名，我想要搞的功能！包括我特别想搞的和我想搞但是想摸的。</p></blockquote><a id="more"></a><h2 id="重要功能">重要功能</h2><ul><li><p>大头菜上市功能</p><ul><li><p>已完成</p><p>增删查改大头菜的价格</p></li><li><p>未完成</p><p>发布大头菜价格到群里</p><blockquote><p>待定使用方法：<code>大头菜 -s</code></p></blockquote><p>隐藏大头菜价格：该功能将使你的大头菜价格不再显示在 <code>大头菜 -l</code> 命令中，这个功能用于你不想别人看到你的大头菜价格，但是又不想删掉这个价格。设置完成后将不影响<strong>发布大头菜</strong>功能。</p></li></ul></li><li><p>上岛功能（待实现）</p><p>增加上岛成员：该功能将添加想上岛的成员，方便批发房间密码。</p><blockquote><p>待定使用方法：<code>岛 -a {QQ号}</code></p></blockquote><p>批发上岛密码：该功能顾名思义，将批发上岛的密码到上岛的人中。</p><blockquote><p>待定使用方法：<code>岛 -p</code></p></blockquote><p>删除上岛成员：该功能将删除上岛成员。</p><p>貌似强制付费的和下架的歌就算有歌曲id也放不了啊，淦。</p><p>    <div id="aplayer-JXDxXeCb" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="30251429" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;正如其名，我想要搞的功能！包括我特别想搞的和我想搞但是想摸的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="xjb写" scheme="https://pzzzzz5142.github.io/categories/xjb%E5%86%99/"/>
    
    
      <category term="To-Do" scheme="https://pzzzzz5142.github.io/tags/To-Do/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们要诚信？</title>
    <link href="https://pzzzzz5142.github.io/%E6%B5%81%E6%B0%B4%E8%B4%A6/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E8%AF%9A%E4%BF%A1/"/>
    <id>https://pzzzzz5142.github.io/%E6%B5%81%E6%B0%B4%E8%B4%A6/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E8%AF%9A%E4%BF%A1/</id>
    <published>2020-03-18T05:06:22.000Z</published>
    <updated>2020-04-05T07:23:07.908Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="prologue">Prologue</h1><p>最近看了罗老师的<a href="https://www.bilibili.com/video/av95872350" target="_blank" rel="noopener">关于诚信的讨论</a>，这让我又不由的又开始思考起道德的观念。罗老师在视频中讨论了两种不同的道德观，一种是道德主义。这种主义认为我们诚信是因为我们认为诚信是好的，诚信是值得我们去遵守的，因此我们守诚信。第二种道德观则是认为我们遵守诚信是因为我们我们认为诚信可以为我们带来好处。就算目前不能带来好处，甚至是会让我们吃亏，但是从长远的角度来看则是会带来可观的收益。这种思想也被称作功力主义。</p><a id="more"></a><p>但是对于这两种看法，罗老师认为他们都有自己的短板。</p><p>首先功力主义的结论是不稳定的，譬如说这个长远的角度又是多久呢？一个生动的例子便是张三开了家店，但是他遵从功利主义，认为诚信是可以带来收益的，而他设定这个长远为3年。结果他亏了三年。隔壁李四天天卖假货，但是赚得盆满钵满。但是他坚信诚信是会带来收益的，于是他又坚持了一年。结果又亏了一年。</p><p>而道德主义又过于教条。当二战时期一位纳粹军官询问一个老太太是否藏匿犹太人的时候，这位老太太若是完全遵守道德主义，那么她也不应该撒谎隐瞒自己藏匿犹太人的事实。因为撒谎是不诚信的体现。由此人们又延伸出了一种叫顾左右而言他的行为来规避撒谎。这种例子数不胜数，在日常生活中并不少见。譬如我小时候到表叔家去玩，打了一下午魂斗罗，然后临走的时候抓起来一本《读者》<del>这书小时候超火的，但是我还是觉得意林好看因为他每一期都有心理测试</del>，看了两分钟。这样，当我回到家我妈问我在表叔家打游戏没有，我就能理直气壮的说我去看书去了。但是，这种行为感觉又给人伪善、虚伪的感觉。</p><h1 id="柏拉图的调和论">柏拉图的调和论</h1><p>柏拉图的调和论中，道德主义和功利主义是可以融合起来的。但是怎么融合的，爷忘了。</p><h1 id="故事又能怎么讲呢">故事又能怎么讲呢？</h1><h2 id="矛盾的故事">矛盾的故事</h2><p>讲述好一个故事，往往是有矛盾，有冲突，这样才精彩，才抓人眼球，有看下去的欲望。譬如在爱情喜剧中，女主和男主总是会有一些戏剧性的冲突，故事发展才自然而又有趣。比如明明是分时段混浴的温泉偏偏有一方看错了时间，结果在温泉中相遇。<del>又或者看到某宁宁在图书馆0712。</del>而看到罗老师关于道德的讨论之后，特别是在他说明我们所处的社会是有多元道德观的时候，我就在想，这种多元的道德观是否能够激发出矛盾，从而构成一个故事的主体呢？</p><p>这让我立马想到的例子就是果宝特工<del>淦，为什么会是这个</del>。当主角花了几十集的时间终于要揭开大boss的真面目之后，结果发现大boss其实是一个基建狂魔，希望让人民住上更好的屋子而不惜强制拆迁。这就是这个故事模型的一个实例。boss的目的时候希望大家的生活更美好，这是道德的。而采取的手段是强制拆迁，这是不道德的。而主角只看到了boss的不道德而没有看到了boss的道德，这就产生了矛盾。而这个矛盾也足以推动故事讲下去，也能解释为什么主角团希望打到boss。因为主角只看到了boss拆迁而没有看到boss重建。</p><p>但是这种故事若是让人觉得boss的手段代价过于庞大，难免也会产生一种强行洗白的感觉。</p><h2 id="实验的故事">实验的故事</h2><p>而另外一种故事则是可以去探讨关于人们心中的道德，到底是什么构成了它们。而从中拿掉或是增加什么来实验性的探讨道德观念也不失为一种讲故事的方法。</p><p>譬如爱情，两人互相喜欢这叫做爱情。那么两人见不着面，能叫爱情吗？这在生活中也是比较常见的，而作为故事主线讲似乎又有些薄弱。那么两人结婚了，向爱情中增添了婚姻的要素，能叫爱情吗？这又更进了一步，没有足够的经验怕也是难以讲出令人信服的故事。那么有第三人相恋了，这又叫爱情吗？在破坏一人感情的基础上成全两人的感情是否又是真正的爱情，是否又是真正的道德呢？这又是一类作品。那我们玄幻一点，两人中的其中一方是能活千年的老王八，而另一方只是一个普普通通的人类，这种不能陪伴到老的爱情，他还是爱情吗？那我们更近一步，换了身体但是精神不变的人还是爱情吗？就如同汤浅政明的《海马》一样，里面的人和思维是可以干干净净的分离的，那换了几十套肉体之后的人，你是会和那个肉体恋爱还是那个精神呢？又如同《魔女的夜宴》中，另一条时间线上的你是否又ntr了你自己呢？</p><p>这种实验性的，往人们观念中增减东西来实验这种观念好会不会变质亦是一种讲故事的思路。但是往往需要足够多的历经才能讲出优秀的故事，否则便很容易落入无病呻吟的漩涡。当然这种故事也是相当精彩的，因为一千个读者便有一千个哈姆雷特，每个人心中都有自己的观念，而看这种作品也会让人思考，你心中的观念又是什么样的，你是否又认为作品中主角的行为符合你的期望？</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;prologue&quot;&gt;Prologue&lt;/h1&gt;
&lt;p&gt;最近看了罗老师的&lt;a href=&quot;https://www.bilibili.com/video/av95872350&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于诚信的讨论&lt;/a&gt;，这让我又不由的又开始思考起道德的观念。罗老师在视频中讨论了两种不同的道德观，一种是道德主义。这种主义认为我们诚信是因为我们认为诚信是好的，诚信是值得我们去遵守的，因此我们守诚信。第二种道德观则是认为我们遵守诚信是因为我们我们认为诚信可以为我们带来好处。就算目前不能带来好处，甚至是会让我们吃亏，但是从长远的角度来看则是会带来可观的收益。这种思想也被称作功力主义。&lt;/p&gt;
    
    </summary>
    
    
      <category term="流水账" scheme="https://pzzzzz5142.github.io/categories/%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
    
      <category term="胡思乱想" scheme="https://pzzzzz5142.github.io/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
      <category term="故事构思" scheme="https://pzzzzz5142.github.io/tags/%E6%95%85%E4%BA%8B%E6%9E%84%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>//Building in progress GHS记录</title>
    <link href="https://pzzzzz5142.github.io/ghs/%E6%9C%AC%E5%AD%90%E8%AE%B0%E5%BD%95/"/>
    <id>https://pzzzzz5142.github.io/ghs/%E6%9C%AC%E5%AD%90%E8%AE%B0%E5%BD%95/</id>
    <published>2020-03-17T03:52:19.000Z</published>
    <updated>2020-04-08T05:58:25.421Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>GHS 是人类进步的基础。 @ Pzzzzz <em>2020.3.17</em></p></blockquote><h1 id="ghsghs">GHS！GHS！</h1><p>呼，总算是完成了首页隐藏文章的操作，但是离我心目中的神隐还是有不少差距的，而且目测文章下面的下一篇文章还是会暴露出GHS的文章。不过，目前技术力不够，更多神隐的操作还是难以搞出来。按照惯例，我搞出来的链接还是会放在文章最后，那么，话不多说，直接开搞！</p><h1 id="本">本</h1><p>疫情在家期间，难免无所事事。但是看了许多本子之后，果然还是觉得大塚まひろ老师画得最好看。某粉红色的软件上关于这位老师的作品，u1s1，我全都喜欢。剧情大部分都是纯爱，蛮甜的。大姐头那一系列去掉hs能上动漫之家都没问题。唯一的一部双男主的本子也画了两条线，可谓是诚意满满。画风方面，就我目前的看来，说是我心中的第一也不为过。</p><figure><img data-src="img-1.jpg" title="随意找了一个本子的封面" alt="某个本子的封面" /><figcaption aria-hidden="true">某个本子的封面</figcaption></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="ghs" scheme="https://pzzzzz5142.github.io/categories/ghs/"/>
    
    
      <category term="ghs" scheme="https://pzzzzz5142.github.io/tags/ghs/"/>
    
  </entry>
  
  <entry>
    <title>折腾博客小结</title>
    <link href="https://pzzzzz5142.github.io/%E9%9A%8F%E7%AC%94/%E5%BB%BA%E7%AB%99/%E6%8A%98%E8%85%BE%E5%8D%9A%E5%AE%A2%E5%B0%8F%E7%BB%93/"/>
    <id>https://pzzzzz5142.github.io/%E9%9A%8F%E7%AC%94/%E5%BB%BA%E7%AB%99/%E6%8A%98%E8%85%BE%E5%8D%9A%E5%AE%A2%E5%B0%8F%E7%BB%93/</id>
    <published>2020-03-16T15:13:02.000Z</published>
    <updated>2020-04-07T04:10:01.789Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="搭搭tmd">搭！搭tmd！</h1><p>老早就想建个博客站了，无奈之前国内的服务器域名要备案国外的vps也不稳。拿个架酸酸乳的vps他配置又不行，装个最新版的wordpress都直呼亚历山大。还好无意之中发现github居然提供静态的网页托管服务，遂爬了一堆教程，终于搭上了博客。</p><a id="more"></a><p>现在网站logo还是用的还是默认的，毕竟懒得找icon了<del>还不是因为懒</del>。但是起码有头像有音乐了！取名为阁楼呢是因为我觉得阁楼就是一个放一些乱七八糟的东西的地方，虽然东西很杂，但是正是因为杂，就可以在里面玩得很开心。<del>侧边栏的音乐用的是apple music，没开的话一首歌只能听30秒就算开了你也只能听30秒，因为你不可能登得上的，而且还影响网站加载速度。那这里你可能就要问了，为什么我还要挂apple music呢，一是因为我觉得好看，二是我想放的音乐<strong>网易云他没版权，生成不了外链！</strong>综上，我就放了个apple music在那里</del>。网站已经换成强大的 aplayer 了！但是只支持电脑端访问。毕竟只有电脑端才有侧边栏。</p><h1 id="怎么搭呢">怎么搭呢？</h1><p>本博客基于hexo+github page，用了NexT主题，配置还算方便。就算你像我一样对前端一点不懂，也能搭出来能用，看起来还说得过去的博客。如果你啥也不会，那么点击<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">这里</a>。这位dalao讲得非常详细了。</p><p>如果你想要美观一点的话，可以尝试使用NexT主题。但是注意要安装最新的NexT主题，之前老的NexT已经不维护了。同时配置的话可以参考这位大大的教程<a href="https://guanqr.com/tech/website/hexo-theme-next-customization/" target="_blank" rel="noopener">链接在这里</a>。这篇教程可以说是讲得非常详细了，而且越算是比较新的教程了。因为在配置主题的时候搜到的许多教程的配置方式还是老的配置方式，最明显的区别就是自定义样式的时候，新版的NexT是在根目录source文件夹下的_data_文件夹里面放上你的自定义的各种乱七八糟的东西，同时要在NexT主题的配置文件中启用你的自定义文件，大概长这样。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件位置 ~/themes/next/_config.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define custom file paths.</span></span><br><span class="line"><span class="comment"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span></span><br><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">postBodyEnd:</span> <span class="string">source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="attr">bodyEnd:</span> <span class="string">source/_data/body-end.swig</span></span><br><span class="line">  <span class="attr">head:</span> <span class="string">source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure><p>大概就是这样，我也会在文末放置一些dalao的教程，当然官方文档也是最最需要看的。</p><h1 id="后记">后记</h1><p>拉拉杂杂写了一大堆，但是这个博客还是有很多能改进的地方，姑且就在这里列出来吧。</p><ul><li><del>能有什么操作能隐藏文章和访问隐藏文章</del>勉强算是有了吧</li><li>侧边栏的黑色搞成彩色（其实也可以不搞</li><li>找一个网站logo</li><li>给网站整个背景</li><li>貌似没了</li></ul><p>不过这些功能目前来说都是可有可无的，等我哪天心情好了可能就有了吧。</p><p>好了，现在这个博客已经基本上能看了，最后放一张大一的时候去吃夜市拍的一张图收尾吧，顺便测试一下图片插入有没有问题。</p><figure><img data-src="IMG_0800.jpeg" title="结果用了一种极其tricky的方法才达成这样的效果。。" alt="w-651 IMG_0800.heic" /><figcaption aria-hidden="true">w-651 IMG_0800.heic</figcaption></figure><h1 id="推荐链接">推荐链接</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">GitHub+Hexo 搭建个人网站详细教程</a></li><li><a href="https://guanqr.com/tech/website/hexo-theme-next-customization/" target="_blank" rel="noopener">Hexo-NexT 主题个性优化</a></li><li><a href="https://io-oi.me/tech/hexo-next-optimization" target="_blank" rel="noopener">打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化 | reuixiy</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;搭搭tmd&quot;&gt;搭！搭tmd！&lt;/h1&gt;
&lt;p&gt;老早就想建个博客站了，无奈之前国内的服务器域名要备案国外的vps也不稳。拿个架酸酸乳的vps他配置又不行，装个最新版的wordpress都直呼亚历山大。还好无意之中发现github居然提供静态的网页托管服务，遂爬了一堆教程，终于搭上了博客。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://pzzzzz5142.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="建站" scheme="https://pzzzzz5142.github.io/categories/%E9%9A%8F%E7%AC%94/%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="折腾" scheme="https://pzzzzz5142.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="建站" scheme="https://pzzzzz5142.github.io/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>万丈高楼从地起</title>
    <link href="https://pzzzzz5142.github.io/%E9%9A%8F%E7%AC%94/%E4%B8%87%E4%B8%88%E9%AB%98%E6%A5%BC%E4%BB%8E%E5%9C%B0%E8%B5%B7/"/>
    <id>https://pzzzzz5142.github.io/%E9%9A%8F%E7%AC%94/%E4%B8%87%E4%B8%88%E9%AB%98%E6%A5%BC%E4%BB%8E%E5%9C%B0%E8%B5%B7/</id>
    <published>2020-03-15T02:14:54.000Z</published>
    <updated>2020-03-17T03:51:54.055Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="试试正文使用大标题">试试正文使用大标题</h1><p>然后，尝试部署一下。</p><p>这大概是真正意义上的第一篇博客吧。</p><p>外观非常简陋（毕竟就套了个默认next主题），但是也算是终于搭上博客了。我会尝试写一些乱七八糟的东西放上去的。</p><p>大概，就是这样吧。。。</p><p>貌似，渲染出来很难看？<del>到时候再改吧，今天就先摸了</del></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://pzzzzz5142.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
